# مثال‌های عملی و موارد استفاده

## پروژه‌های وب

### 🌐 **توسعه Frontend**

#### ۱. ایجاد React Component
```jsx
// درخواست: "یک کامپوننت UserCard برای نمایش اطلاعات کاربر بساز"

import React from 'react';
import { User } from '../types/User';
import './UserCard.css';

interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (userId: string) => void;
  isEditable?: boolean;
}

const UserCard: React.FC<UserCardProps> = ({ 
  user, 
  onEdit, 
  onDelete, 
  isEditable = false 
}) => {
  const handleEdit = () => {
    if (onEdit && user) {
      onEdit(user);
    }
  };

  const handleDelete = () => {
    if (onDelete && user.id) {
      if (window.confirm('آیا از حذف این کاربر اطمینان دارید؟')) {
        onDelete(user.id);
      }
    }
  };

  return (
    <div className="user-card" data-testid="user-card">
      <div className="user-avatar">
        <img 
          src={user.avatar || '/default-avatar.png'} 
          alt={`${user.name} avatar`}
          onError={(e) => {
            e.currentTarget.src = '/default-avatar.png';
          }}
        />
      </div>
      
      <div className="user-info">
        <h3 className="user-name">{user.name}</h3>
        <p className="user-email">{user.email}</p>
        <p className="user-role">{user.role}</p>
        
        {user.lastLogin && (
          <span className="last-login">
            آخرین ورود: {new Date(user.lastLogin).toLocaleDateString('fa-IR')}
          </span>
        )}
      </div>
      
      {isEditable && (
        <div className="user-actions">
          <button 
            onClick={handleEdit}
            className="btn btn-primary"
            aria-label={`ویرایش ${user.name}`}
          >
            ویرایش
          </button>
          <button 
            onClick={handleDelete}
            className="btn btn-danger"
            aria-label={`حذف ${user.name}`}
          >
            حذف
          </button>
        </div>
      )}
    </div>
  );
};

export default UserCard;
```

#### ۲. State Management با Redux
```typescript
// درخواست: "یک Redux store برای مدیریت کاربران بساز"

// types/user.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'moderator';
  avatar?: string;
  lastLogin?: string;
  isActive: boolean;
}

export interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
  selectedUser: User | null;
}

// store/userSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { User, UserState } from '../types/user';
import { userApi } from '../services/userApi';

// Async thunks
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async (_, { rejectWithValue }) => {
    try {
      const response = await userApi.getUsers();
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

export const createUser = createAsyncThunk(
  'users/createUser',
  async (userData: Omit<User, 'id'>, { rejectWithValue }) => {
    try {
      const response = await userApi.createUser(userData);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

const initialState: UserState = {
  users: [],
  loading: false,
  error: null,
  selectedUser: null,
};

const userSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    selectUser: (state, action: PayloadAction<User>) => {
      state.selectedUser = action.payload;
    },
    clearSelectedUser: (state) => {
      state.selectedUser = null;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch users
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Create user
      .addCase(createUser.fulfilled, (state, action) => {
        state.users.push(action.payload);
      });
  },
});

export const { selectUser, clearSelectedUser, clearError } = userSlice.actions;
export default userSlice.reducer;
```

### 🔧 **توسعه Backend**

#### ۱. Express.js API
```javascript
// درخواست: "یک REST API کامل برای مدیریت محصولات بساز"

// models/Product.js
const mongoose = require('mongoose');

const productSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'نام محصول الزامی است'],
    trim: true,
    maxlength: [100, 'نام محصول نمی‌تواند بیش از 100 کاراکتر باشد']
  },
  description: {
    type: String,
    required: [true, 'توضیحات محصول الزامی است'],
    maxlength: [1000, 'توضیحات نمی‌تواند بیش از 1000 کاراکتر باشد']
  },
  price: {
    type: Number,
    required: [true, 'قیمت محصول الزامی است'],
    min: [0, 'قیمت نمی‌تواند منفی باشد']
  },
  category: {
    type: String,
    required: [true, 'دسته‌بندی محصول الزامی است'],
    enum: ['electronics', 'clothing', 'books', 'home', 'sports']
  },
  stock: {
    type: Number,
    required: true,
    min: [0, 'موجودی نمی‌تواند منفی باشد'],
    default: 0
  },
  images: [{
    url: String,
    alt: String
  }],
  isActive: {
    type: Boolean,
    default: true
  },
  tags: [String],
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Indexes برای عملکرد بهتر
productSchema.index({ name: 'text', description: 'text' });
productSchema.index({ category: 1, price: 1 });
productSchema.index({ createdAt: -1 });

module.exports = mongoose.model('Product', productSchema);

// controllers/productController.js
const Product = require('../models/Product');
const { validationResult } = require('express-validator');

class ProductController {
  // دریافت تمام محصولات با فیلتر و صفحه‌بندی
  async getProducts(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const skip = (page - 1) * limit;
      
      const filter = {};
      
      // فیلترهای اختیاری
      if (req.query.category) {
        filter.category = req.query.category;
      }
      
      if (req.query.minPrice || req.query.maxPrice) {
        filter.price = {};
        if (req.query.minPrice) filter.price.$gte = parseFloat(req.query.minPrice);
        if (req.query.maxPrice) filter.price.$lte = parseFloat(req.query.maxPrice);
      }
      
      if (req.query.search) {
        filter.$text = { $search: req.query.search };
      }
      
      const products = await Product.find(filter)
        .populate('createdBy', 'name email')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit);
      
      const total = await Product.countDocuments(filter);
      
      res.json({
        success: true,
        data: products,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت محصولات',
        error: error.message
      });
    }
  }
  
  // ایجاد محصول جدید
  async createProduct(req, res) {
    try {
      // بررسی validation errors
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'داده‌های ورودی نامعتبر',
          errors: errors.array()
        });
      }
      
      const productData = {
        ...req.body,
        createdBy: req.user.id
      };
      
      const product = new Product(productData);
      await product.save();
      
      // Populate creator info
      await product.populate('createdBy', 'name email');
      
      res.status(201).json({
        success: true,
        message: 'محصول با موفقیت ایجاد شد',
        data: product
      });
    } catch (error) {
      if (error.name === 'ValidationError') {
        const validationErrors = Object.values(error.errors).map(err => err.message);
        return res.status(400).json({
          success: false,
          message: 'خطا در اعتبارسنجی داده‌ها',
          errors: validationErrors
        });
      }
      
      res.status(500).json({
        success: false,
        message: 'خطا در ایجاد محصول',
        error: error.message
      });
    }
  }
}

module.exports = new ProductController();
```

### 📱 **توسعه Mobile**

#### ۱. React Native App
```javascript
// درخواست: "یک اپ موبایل برای فروشگاه آنلاین بساز"

// screens/ProductListScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  Image,
  TouchableOpacity,
  StyleSheet,
  RefreshControl,
  ActivityIndicator
} from 'react-native';
import { useNavigation } from '@react-navigation/native';

const ProductListScreen = () => {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const navigation = useNavigation();

  useEffect(() => {
    fetchProducts();
  }, []);

  const fetchProducts = async () => {
    try {
      const response = await fetch('https://api.example.com/products');
      const data = await response.json();
      setProducts(data.products);
    } catch (error) {
      console.error('خطا در دریافت محصولات:', error);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const onRefresh = () => {
    setRefreshing(true);
    fetchProducts();
  };

  const renderProduct = ({ item }) => (
    <TouchableOpacity
      style={styles.productCard}
      onPress={() => navigation.navigate('ProductDetail', { productId: item.id })}
      accessibilityLabel={`محصول ${item.name}`}
    >
      <Image 
        source={{ uri: item.images[0]?.url }} 
        style={styles.productImage}
        resizeMode="cover"
      />
      <View style={styles.productInfo}>
        <Text style={styles.productName} numberOfLines={2}>
          {item.name}
        </Text>
        <Text style={styles.productPrice}>
          {item.price.toLocaleString('fa-IR')} تومان
        </Text>
        <View style={styles.productMeta}>
          <Text style={styles.productCategory}>{item.category}</Text>
          <Text style={styles.productStock}>
            موجودی: {item.stock}
          </Text>
        </View>
      </View>
    </TouchableOpacity>
  );

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007AFF" />
        <Text style={styles.loadingText}>در حال بارگذاری...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={products}
        renderItem={renderProduct}
        keyExtractor={(item) => item.id}
        numColumns={2}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
        contentContainerStyle={styles.listContainer}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  listContainer: {
    padding: 10,
  },
  productCard: {
    flex: 1,
    margin: 5,
    backgroundColor: 'white',
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  productImage: {
    width: '100%',
    height: 150,
    borderTopLeftRadius: 12,
    borderTopRightRadius: 12,
  },
  productInfo: {
    padding: 12,
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8,
  },
  productPrice: {
    fontSize: 18,
    fontWeight: '600',
    color: '#007AFF',
    marginBottom: 8,
  },
  productMeta: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
  },
  productStock: {
    fontSize: 12,
    color: '#666',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    color: '#666',
  },
});

export default ProductListScreen;
```

#### ۲. Flutter App Development
```dart
// درخواست: "یک صفحه لیست محصولات در Flutter بساز"

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class Product {
  final String id;
  final String name;
  final String description;
  final double price;
  final String imageUrl;
  final int stock;

  Product({
    required this.id,
    required this.name,
    required this.description,
    required this.price,
    required this.imageUrl,
    required this.stock,
  });

  factory Product.fromJson(Map<String, dynamic> json) {
    return Product(
      id: json['id'],
      name: json['name'],
      description: json['description'],
      price: json['price'].toDouble(),
      imageUrl: json['imageUrl'] ?? '',
      stock: json['stock'],
    );
  }
}

class ProductListScreen extends StatefulWidget {
  @override
  _ProductListScreenState createState() => _ProductListScreenState();
}

class _ProductListScreenState extends State<ProductListScreen> {
  List<Product> products = [];
  bool isLoading = true;
  String? error;

  @override
  void initState() {
    super.initState();
    fetchProducts();
  }

  Future<void> fetchProducts() async {
    try {
      final response = await http.get(
        Uri.parse('https://api.example.com/products'),
        headers: {'Content-Type': 'application/json'},
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        setState(() {
          products = (data['products'] as List)
              .map((item) => Product.fromJson(item))
              .toList();
          isLoading = false;
        });
      } else {
        throw Exception('خطا در دریافت محصولات');
      }
    } catch (e) {
      setState(() {
        error = e.toString();
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('محصولات'),
        backgroundColor: Colors.blue[600],
        foregroundColor: Colors.white,
      ),
      body: isLoading
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('در حال بارگذاری...'),
                ],
              ),
            )
          : error != null
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.error, size: 64, color: Colors.red),
                      SizedBox(height: 16),
                      Text(error!),
                      SizedBox(height: 16),
                      ElevatedButton(
                        onPressed: () {
                          setState(() {
                            isLoading = true;
                            error = null;
                          });
                          fetchProducts();
                        },
                        child: Text('تلاش مجدد'),
                      ),
                    ],
                  ),
                )
              : RefreshIndicator(
                  onRefresh: fetchProducts,
                  child: GridView.builder(
                    padding: EdgeInsets.all(16),
                    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 2,
                      crossAxisSpacing: 16,
                      mainAxisSpacing: 16,
                      childAspectRatio: 0.75,
                    ),
                    itemCount: products.length,
                    itemBuilder: (context, index) {
                      final product = products[index];
                      return ProductCard(product: product);
                    },
                  ),
                ),
    );
  }
}

class ProductCard extends StatelessWidget {
  final Product product;

  const ProductCard({Key? key, required this.product}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: () {
          Navigator.pushNamed(
            context,
            '/product-detail',
            arguments: product.id,
          );
        },
        borderRadius: BorderRadius.circular(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 3,
              child: Container(
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.vertical(top: Radius.circular(12)),
                  image: DecorationImage(
                    image: NetworkImage(product.imageUrl),
                    fit: BoxFit.cover,
                    onError: (error, stackTrace) {
                      // Handle image loading error
                    },
                  ),
                ),
              ),
            ),
            Expanded(
              flex: 2,
              child: Padding(
                padding: EdgeInsets.all(12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      product.name,
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    Spacer(),
                    Text(
                      '${product.price.toStringAsFixed(0)} تومان',
                      style: TextStyle(
                        color: Colors.blue[600],
                        fontWeight: FontWeight.w600,
                        fontSize: 16,
                      ),
                    ),
                    SizedBox(height: 4),
                    Text(
                      'موجودی: ${product.stock}',
                      style: TextStyle(
                        color: Colors.grey[600],
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

## پروژه‌های علوم داده

### 📊 **تحلیل داده با Python**

#### ۱. Data Analysis Pipeline
```python
# درخواست: "یک pipeline کامل برای تحلیل داده‌های فروش بساز"

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# تنظیمات matplotlib برای فارسی
plt.rcParams['font.family'] = 'DejaVu Sans'
plt.rcParams['figure.figsize'] = (12, 8)

class SalesAnalyzer:
    def __init__(self, data_path: str):
        """
        تحلیلگر داده‌های فروش
        
        Args:
            data_path: مسیر فایل داده‌های فروش
        """
        self.data_path = data_path
        self.df = None
        self.cleaned_df = None
        
    def load_data(self):
        """بارگذاری و بررسی اولیه داده‌ها"""
        try:
            self.df = pd.read_csv(self.data_path)
            print(f"✅ داده‌ها بارگذاری شد: {self.df.shape[0]} رکورد، {self.df.shape[1]} ستون")
            
            # نمایش اطلاعات کلی
            print("\n📊 اطلاعات کلی داده‌ها:")
            print(self.df.info())
            
            print("\n📈 آمار توصیفی:")
            print(self.df.describe())
            
            return True
        except Exception as e:
            print(f"❌ خطا در بارگذاری داده‌ها: {e}")
            return False
    
    def clean_data(self):
        """تمیزسازی و آماده‌سازی داده‌ها"""
        if self.df is None:
            print("❌ ابتدا داده‌ها را بارگذاری کنید")
            return False
            
        self.cleaned_df = self.df.copy()
        
        # تبدیل تاریخ‌ها
        date_columns = ['order_date', 'delivery_date']
        for col in date_columns:
            if col in self.cleaned_df.columns:
                self.cleaned_df[col] = pd.to_datetime(self.cleaned_df[col])
        
        # حذف مقادیر null
        initial_rows = len(self.cleaned_df)
        self.cleaned_df = self.cleaned_df.dropna(subset=['order_id', 'customer_id', 'amount'])
        removed_rows = initial_rows - len(self.cleaned_df)
        
        if removed_rows > 0:
            print(f"🧹 {removed_rows} رکورد ناقص حذف شد")
        
        # حذف مقادیر منفی
        self.cleaned_df = self.cleaned_df[self.cleaned_df['amount'] > 0]
        
        # اضافه کردن ستون‌های محاسباتی
        if 'order_date' in self.cleaned_df.columns:
            self.cleaned_df['year'] = self.cleaned_df['order_date'].dt.year
            self.cleaned_df['month'] = self.cleaned_df['order_date'].dt.month
            self.cleaned_df['day_of_week'] = self.cleaned_df['order_date'].dt.day_name()
        
        print(f"✅ داده‌ها تمیز شد: {len(self.cleaned_df)} رکورد باقی ماند")
        return True
    
    def analyze_sales_trends(self):
        """تحلیل روندهای فروش"""
        if self.cleaned_df is None:
            print("❌ ابتدا داده‌ها را تمیز کنید")
            return
        
        # فروش ماهانه
        monthly_sales = self.cleaned_df.groupby(['year', 'month'])['amount'].agg([
            'sum', 'count', 'mean'
        ]).reset_index()
        
        monthly_sales['date'] = pd.to_datetime(monthly_sales[['year', 'month']].assign(day=1))
        
        # رسم نمودار فروش ماهانه
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        
        # نمودار 1: مجموع فروش ماهانه
        axes[0, 0].plot(monthly_sales['date'], monthly_sales['sum'], marker='o')
        axes[0, 0].set_title('مجموع فروش ماهانه')
        axes[0, 0].set_xlabel('ماه')
        axes[0, 0].set_ylabel('مبلغ فروش')
        axes[0, 0].tick_params(axis='x', rotation=45)
        
        # نمودار 2: تعداد سفارشات ماهانه
        axes[0, 1].bar(monthly_sales['date'], monthly_sales['count'], alpha=0.7)
        axes[0, 1].set_title('تعداد سفارشات ماهانه')
        axes[0, 1].set_xlabel('ماه')
        axes[0, 1].set_ylabel('تعداد سفارش')
        
        # نمودار 3: میانگین مبلغ سفارش
        axes[1, 0].plot(monthly_sales['date'], monthly_sales['mean'], 
                       marker='s', color='green')
        axes[1, 0].set_title('میانگین مبلغ سفارش ماهانه')
        axes[1, 0].set_xlabel('ماه')
        axes[1, 0].set_ylabel('میانگین مبلغ')
        
        # نمودار 4: فروش بر اساس روز هفته
        daily_sales = self.cleaned_df.groupby('day_of_week')['amount'].sum()
        day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        daily_sales = daily_sales.reindex(day_order)
        
        axes[1, 1].bar(range(len(daily_sales)), daily_sales.values)
        axes[1, 1].set_title('فروش بر اساس روز هفته')
        axes[1, 1].set_xlabel('روز هفته')
        axes[1, 1].set_ylabel('مجموع فروش')
        axes[1, 1].set_xticks(range(len(daily_sales)))
        axes[1, 1].set_xticklabels(['دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنج‌شنبه', 'جمعه', 'شنبه', 'یکشنبه'])
        
        plt.tight_layout()
        plt.show()
        
        return monthly_sales
    
    def customer_segmentation(self):
        """تقسیم‌بندی مشتریان بر اساس RFM"""
        # محاسبه RFM
        current_date = self.cleaned_df['order_date'].max()
        
        rfm = self.cleaned_df.groupby('customer_id').agg({
            'order_date': lambda x: (current_date - x.max()).days,  # Recency
            'order_id': 'count',  # Frequency
            'amount': 'sum'  # Monetary
        }).reset_index()
        
        rfm.columns = ['customer_id', 'recency', 'frequency', 'monetary']
        
        # تقسیم‌بندی به quartile ها
        rfm['r_score'] = pd.qcut(rfm['recency'], 4, labels=[4, 3, 2, 1])
        rfm['f_score'] = pd.qcut(rfm['frequency'].rank(method='first'), 4, labels=[1, 2, 3, 4])
        rfm['m_score'] = pd.qcut(rfm['monetary'], 4, labels=[1, 2, 3, 4])
        
        # ایجاد RFM Score
        rfm['rfm_score'] = rfm['r_score'].astype(str) + rfm['f_score'].astype(str) + rfm['m_score'].astype(str)
        
        # تعریف segments
        def segment_customers(row):
            if row['rfm_score'] in ['444', '443', '434', '344']:
                return 'Champions'
            elif row['rfm_score'] in ['433', '343', '334', '333']:
                return 'Loyal Customers'
            elif row['rfm_score'] in ['431', '341', '314', '313']:
                return 'Potential Loyalists'
            elif row['rfm_score'] in ['421', '411', '321', '311']:
                return 'New Customers'
            elif row['rfm_score'] in ['422', '412', '322', '312']:
                return 'Promising'
            elif row['rfm_score'] in ['142', '132', '123', '122']:
                return 'At Risk'
            elif row['rfm_score'] in ['141', '131', '121', '111']:
                return 'Cannot Lose Them'
            else:
                return 'Others'
        
        rfm['segment'] = rfm.apply(segment_customers, axis=1)
        
        # نمایش نتایج
        segment_summary = rfm['segment'].value_counts()
        print("📊 تقسیم‌بندی مشتریان:")
        print(segment_summary)
        
        # رسم نمودار segments
        plt.figure(figsize=(10, 6))
        segment_summary.plot(kind='bar')
        plt.title('تقسیم‌بندی مشتریان بر اساس RFM')
        plt.xlabel('نوع مشتری')
        plt.ylabel('تعداد')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()
        
        return rfm

# استفاده از کلاس
analyzer = SalesAnalyzer('sales_data.csv')
analyzer.load_data()
analyzer.clean_data()
trends = analyzer.analyze_sales_trends()
rfm_analysis = analyzer.customer_segmentation()
```

### 🧠 **Machine Learning Projects**

#### ۱. Prediction Model
```python
# درخواست: "یک مدل پیش‌بینی قیمت خانه بساز"

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import joblib

class HousePricePredictor:
    def __init__(self):
        self.models = {}
        self.scaler = StandardScaler()
        self.label_encoders = {}
        self.feature_names = []
        
    def load_and_prepare_data(self, file_path: str):
        """بارگذاری و آماده‌سازی داده‌ها"""
        # بارگذاری داده‌ها
        self.df = pd.read_csv(file_path)
        print(f"📊 داده‌ها بارگذاری شد: {self.df.shape}")
        
        # بررسی مقادیر null
        null_counts = self.df.isnull().sum()
        if null_counts.sum() > 0:
            print("⚠️ مقادیر null یافت شد:")
            print(null_counts[null_counts > 0])
        
        # تمیزسازی داده‌ها
        self.df = self.df.dropna()
        
        # حذف outliers
        numeric_columns = self.df.select_dtypes(include=[np.number]).columns
        for col in numeric_columns:
            if col != 'price':  # قیمت را نگه می‌داریم
                Q1 = self.df[col].quantile(0.25)
                Q3 = self.df[col].quantile(0.75)
                IQR = Q3 - Q1
                lower_bound = Q1 - 1.5 * IQR
                upper_bound = Q3 + 1.5 * IQR
                self.df = self.df[(self.df[col] >= lower_bound) & (self.df[col] <= upper_bound)]
        
        print(f"✅ داده‌ها تمیز شد: {self.df.shape}")
        
    def feature_engineering(self):
        """مهندسی ویژگی"""
        # ایجاد ویژگی‌های جدید
        self.df['price_per_sqft'] = self.df['price'] / self.df['sqft_living']
        self.df['total_rooms'] = self.df['bedrooms'] + self.df['bathrooms']
        self.df['age'] = 2024 - self.df['yr_built']
        
        # تبدیل متغیرهای categorical
        categorical_columns = self.df.select_dtypes(include=['object']).columns
        
        for col in categorical_columns:
            if col != 'price':  # اگر قیمت string باشد
                le = LabelEncoder()
                self.df[col] = le.fit_transform(self.df[col])
                self.label_encoders[col] = le
        
        print("🔧 مهندسی ویژگی انجام شد")
        
    def train_models(self):
        """آموزش مدل‌های مختلف"""
        # تعریف features و target
        X = self.df.drop(['price'], axis=1)
        y = self.df['price']
        
        self.feature_names = X.columns.tolist()
        
        # تقسیم داده‌ها
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42
        )
        
        # استانداردسازی
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)
        
        # تعریف مدل‌ها
        models = {
            'Linear Regression': LinearRegression(),
            'Random Forest': RandomForestRegressor(n_estimators=100, random_state=42),
            'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, random_state=42)
        }
        
        # آموزش و ارزیابی مدل‌ها
        results = {}
        
        for name, model in models.items():
            print(f"\n🤖 آموزش {name}...")
            
            if name == 'Linear Regression':
                model.fit(X_train_scaled, y_train)
                y_pred = model.predict(X_test_scaled)
            else:
                model.fit(X_train, y_train)
                y_pred = model.predict(X_test)
            
            # محاسبه متریک‌ها
            mae = mean_absolute_error(y_test, y_pred)
            mse = mean_squared_error(y_test, y_pred)
            rmse = np.sqrt(mse)
            r2 = r2_score(y_test, y_pred)
            
            results[name] = {
                'model': model,
                'mae': mae,
                'rmse': rmse,
                'r2': r2,
                'predictions': y_pred
            }
            
            print(f"📊 نتایج {name}:")
            print(f"  MAE: {mae:,.0f}")
            print(f"  RMSE: {rmse:,.0f}")
            print(f"  R²: {r2:.3f}")
        
        self.models = results
        
        # انتخاب بهترین مدل
        best_model_name = max(results.keys(), key=lambda x: results[x]['r2'])
        self.best_model = results[best_model_name]['model']
        print(f"\n🏆 بهترین مدل: {best_model_name}")
        
        return results
    
    def visualize_results(self):
        """تصویری‌سازی نتایج"""
        if not self.models:
            print("❌ ابتدا مدل‌ها را آموزش دهید")
            return
        
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        
        # مقایسه مدل‌ها
        model_names = list(self.models.keys())
        r2_scores = [self.models[name]['r2'] for name in model_names]
        
        axes[0, 0].bar(model_names, r2_scores)
        axes[0, 0].set_title('مقایسه دقت مدل‌ها (R² Score)')
        axes[0, 0].set_ylabel('R² Score')
        axes[0, 0].tick_params(axis='x', rotation=45)
        
        # Feature importance (برای Random Forest)
        if 'Random Forest' in self.models:
            rf_model = self.models['Random Forest']['model']
            feature_importance = pd.DataFrame({
                'feature': self.feature_names,
                'importance': rf_model.feature_importances_
            }).sort_values('importance', ascending=False).head(10)
            
            axes[0, 1].barh(feature_importance['feature'], feature_importance['importance'])
            axes[0, 1].set_title('اهمیت ویژگی‌ها (Random Forest)')
            axes[0, 1].set_xlabel('اهمیت')
        
        # توزیع قیمت‌ها
        axes[1, 0].hist(self.df['price'], bins=50, alpha=0.7)
        axes[1, 0].set_title('توزیع قیمت خانه‌ها')
        axes[1, 0].set_xlabel('قیمت')
        axes[1, 0].set_ylabel('فراوانی')
        
        # رابطه قیمت و متراژ
        axes[1, 1].scatter(self.df['sqft_living'], self.df['price'], alpha=0.5)
        axes[1, 1].set_title('رابطه قیمت و متراژ')
        axes[1, 1].set_xlabel('متراژ (فوت مربع)')
        axes[1, 1].set_ylabel('قیمت')
        
        plt.tight_layout()
        plt.show()
    
    def predict_price(self, house_features: dict):
        """پیش‌بینی قیمت خانه جدید"""
        if self.best_model is None:
            print("❌ ابتدا مدل را آموزش دهید")
            return None
        
        # تبدیل به DataFrame
        features_df = pd.DataFrame([house_features])
        
        # اعمال label encoders
        for col, encoder in self.label_encoders.items():
            if col in features_df.columns:
                features_df[col] = encoder.transform(features_df[col])
        
        # پیش‌بینی
        if isinstance(self.best_model, LinearRegression):
            features_scaled = self.scaler.transform(features_df)
            prediction = self.best_model.predict(features_scaled)[0]
        else:
            prediction = self.best_model.predict(features_df)[0]
        
        return prediction
    
    def save_model(self, file_path: str):
        """ذخیره مدل آموزش‌دیده"""
        model_data = {
            'model': self.best_model,
            'scaler': self.scaler,
            'label_encoders': self.label_encoders,
            'feature_names': self.feature_names
        }
        
        joblib.dump(model_data, file_path)
        print(f"💾 مدل ذخیره شد: {file_path}")

# استفاده از کلاس
predictor = HousePricePredictor()
predictor.load_and_prepare_data('house_data.csv')
predictor.feature_engineering()
results = predictor.train_models()
predictor.visualize_results()

# پیش‌بینی برای خانه جدید
new_house = {
    'bedrooms': 3,
    'bathrooms': 2,
    'sqft_living': 2000,
    'sqft_lot': 5000,
    'floors': 2,
    'waterfront': 0,
    'view': 2,
    'condition': 3,
    'grade': 7,
    'yr_built': 1990
}

predicted_price = predictor.predict_price(new_house)
print(f"💰 قیمت پیش‌بینی شده: {predicted_price:,.0f} دلار")
```

## پروژه‌های DevOps

### 🐳 **Docker و Containerization**

#### ۱. Multi-stage Dockerfile
```dockerfile
# درخواست: "یک Dockerfile بهینه برای اپلیکیشن Node.js بساز"

# Build stage
FROM node:18-alpine AS builder

# نصب dependencies مورد نیاز برای build
RUN apk add --no-cache python3 make g++

WORKDIR /app

# کپی package files
COPY package*.json ./
COPY yarn.lock* ./

# نصب dependencies
RUN npm ci --only=production && npm cache clean --force

# کپی source code
COPY . .

# Build application
RUN npm run build

# Runtime stage
FROM node:18-alpine AS runtime

# ایجاد non-root user برای امنیت
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

WORKDIR /app

# کپی فقط فایل‌های مورد نیاز
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json

# تنظیم permissions
RUN chown -R nextjs:nodejs /app
USER nextjs

# تنظیم environment variables
ENV NODE_ENV=production
ENV PORT=3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Expose port
EXPOSE 3000

# Start application
CMD ["npm", "start"]
```

#### ۲. Docker Compose Setup
```yaml
# درخواست: "یک docker-compose برای full-stack app بساز"

version: '3.8'

services:
  # Frontend (React)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://localhost:5000/api
    depends_on:
      - backend
    volumes:
      - ./frontend:/app
      - /app/node_modules
    networks:
      - app-network

  # Backend (Node.js)
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=myapp
      - DB_USER=postgres
      - DB_PASS=password
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=your-secret-key
    depends_on:
      - postgres
      - redis
    volumes:
      - ./backend:/app
      - /app/node_modules
    networks:
      - app-network

  # Database (PostgreSQL)
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - app-network

  # Cache (Redis)
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app-network

  # Nginx (Reverse Proxy)
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend
    networks:
      - app-network

volumes:
  postgres_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

#### ۳. Kubernetes Deployment
```yaml
# درخواست: "تنظیمات Kubernetes برای deploy کردن app بساز"

# namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: myapp-production

---
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: myapp-production
data:
  NODE_ENV: "production"
  API_URL: "https://api.myapp.com"
  LOG_LEVEL: "info"

---
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: myapp-production
type: Opaque
data:
  DB_PASSWORD: cGFzc3dvcmQ=  # base64 encoded
  JWT_SECRET: eW91ci1zZWNyZXQta2V5  # base64 encoded

---
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
  namespace: myapp-production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: myapp/backend:latest
        ports:
        - containerPort: 5000
        env:
        - name: NODE_ENV
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: NODE_ENV
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: DB_PASSWORD
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5

---
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: myapp-production
spec:
  selector:
    app: backend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5000
  type: ClusterIP

---
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  namespace: myapp-production
  annotations:
    kubernetes.io/ingress.class: "nginx"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
  tls:
  - hosts:
    - api.myapp.com
    secretName: app-tls
  rules:
  - host: api.myapp.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: backend-service
            port:
              number: 80
```

## پروژه‌های تخصصی

### 🔐 **سیستم احراز هویت کامل**

#### ۱. JWT Authentication System
```javascript
// درخواست: "یک سیستم کامل احراز هویت با JWT بساز"

// middleware/auth.js
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const rateLimit = require('express-rate-limit');
const User = require('../models/User');

// Rate limiting برای login
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 دقیقه
  max: 5, // حداکثر 5 تلاش
  message: {
    error: 'تعداد تلاش‌های ورود بیش از حد مجاز. لطفاً 15 دقیقه صبر کنید.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

class AuthService {
  // تولید JWT token
  generateTokens(userId) {
    const accessToken = jwt.sign(
      { userId, type: 'access' },
      process.env.JWT_ACCESS_SECRET,
      { expiresIn: '15m' }
    );
    
    const refreshToken = jwt.sign(
      { userId, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    return { accessToken, refreshToken };
  }
  
  // تأیید access token
  verifyAccessToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_ACCESS_SECRET);
    } catch (error) {
      throw new Error('توکن نامعتبر یا منقضی شده');
    }
  }
  
  // تأیید refresh token
  verifyRefreshToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_REFRESH_SECRET);
    } catch (error) {
      throw new Error('توکن تازه‌سازی نامعتبر');
    }
  }
  
  // hash کردن رمز عبور
  async hashPassword(password) {
    const saltRounds = 12;
    return await bcrypt.hash(password, saltRounds);
  }
  
  // مقایسه رمز عبور
  async comparePassword(password, hashedPassword) {
    return await bcrypt.compare(password, hashedPassword);
  }
}

// Middleware برای تأیید authentication
const authenticateToken = async (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'توکن دسترسی الزامی است'
      });
    }
    
    const authService = new AuthService();
    const decoded = authService.verifyAccessToken(token);
    
    // بررسی وجود کاربر
    const user = await User.findById(decoded.userId).select('-password');
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'کاربر یافت نشد'
      });
    }
    
    // بررسی فعال بودن حساب
    if (!user.isActive) {
      return res.status(401).json({
        success: false,
        message: 'حساب کاربری غیرفعال است'
      });
    }
    
    req.user = user;
    next();
  } catch (error) {
    res.status(403).json({
      success: false,
      message: error.message
    });
  }
};

// controllers/authController.js
class AuthController {
  // ثبت‌نام کاربر جدید
  async register(req, res) {
    try {
      const { name, email, password } = req.body;
      
      // بررسی وجود کاربر
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: 'کاربری با این ایمیل قبلاً ثبت‌نام کرده است'
        });
      }
      
      // اعتبارسنجی رمز عبور
      if (password.length < 8) {
        return res.status(400).json({
          success: false,
          message: 'رمز عبور باید حداقل 8 کاراکتر باشد'
        });
      }
      
      const authService = new AuthService();
      const hashedPassword = await authService.hashPassword(password);
      
      // ایجاد کاربر جدید
      const user = new User({
        name,
        email,
        password: hashedPassword,
        role: 'user',
        isActive: true
      });
      
      await user.save();
      
      // تولید tokens
      const tokens = authService.generateTokens(user._id);
      
      // ذخیره refresh token در database
      user.refreshToken = tokens.refreshToken;
      await user.save();
      
      res.status(201).json({
        success: true,
        message: 'ثبت‌نام با موفقیت انجام شد',
        user: {
          id: user._id,
          name: user.name,
          email: user.email,
          role: user.role
        },
        tokens
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در ثبت‌نام',
        error: error.message
      });
    }
  }
  
  // ورود کاربر
  async login(req, res) {
    try {
      const { email, password } = req.body;
      
      // یافتن کاربر
      const user = await User.findOne({ email });
      if (!user) {
        return res.status(401).json({
          success: false,
          message: 'ایمیل یا رمز عبور اشتباه است'
        });
      }
      
      // بررسی فعال بودن حساب
      if (!user.isActive) {
        return res.status(401).json({
          success: false,
          message: 'حساب کاربری غیرفعال است'
        });
      }
      
      // تأیید رمز عبور
      const authService = new AuthService();
      const isValidPassword = await authService.comparePassword(password, user.password);
      
      if (!isValidPassword) {
        return res.status(401).json({
          success: false,
          message: 'ایمیل یا رمز عبور اشتباه است'
        });
      }
      
      // تولید tokens جدید
      const tokens = authService.generateTokens(user._id);
      
      // به‌روزرسانی refresh token و آخرین ورود
      user.refreshToken = tokens.refreshToken;
      user.lastLogin = new Date();
      await user.save();
      
      res.json({
        success: true,
        message: 'ورود موفقیت‌آمیز',
        user: {
          id: user._id,
          name: user.name,
          email: user.email,
          role: user.role
        },
        tokens
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در ورود',
        error: error.message
      });
    }
  }
  
  // تازه‌سازی token
  async refreshToken(req, res) {
    try {
      const { refreshToken } = req.body;
      
      if (!refreshToken) {
        return res.status(401).json({
          success: false,
          message: 'توکن تازه‌سازی الزامی است'
        });
      }
      
      const authService = new AuthService();
      const decoded = authService.verifyRefreshToken(refreshToken);
      
      // یافتن کاربر و تأیید refresh token
      const user = await User.findById(decoded.userId);
      if (!user || user.refreshToken !== refreshToken) {
        return res.status(403).json({
          success: false,
          message: 'توکن تازه‌سازی نامعتبر'
        });
      }
      
      // تولید tokens جدید
      const newTokens = authService.generateTokens(user._id);
      
      // به‌روزرسانی refresh token
      user.refreshToken = newTokens.refreshToken;
      await user.save();
      
      res.json({
        success: true,
        tokens: newTokens
      });
    } catch (error) {
      res.status(403).json({
        success: false,
        message: 'خطا در تازه‌سازی توکن',
        error: error.message
      });
    }
  }
  
  // خروج کاربر
  async logout(req, res) {
    try {
      const user = await User.findById(req.user.id);
      if (user) {
        user.refreshToken = null;
        await user.save();
      }
      
      res.json({
        success: true,
        message: 'خروج موفقیت‌آمیز'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در خروج',
        error: error.message
      });
    }
  }
}

module.exports = { AuthController: new AuthController(), loginLimiter, authenticateToken };
```

### ☁️ **Cloud Deployment**

#### ۱. AWS Lambda Function
```javascript
// درخواست: "یک Lambda function برای پردازش تصاویر بساز"

const AWS = require('aws-sdk');
const sharp = require('sharp');

// تنظیم AWS services
const s3 = new AWS.S3();
const sns = new AWS.SNS();

exports.handler = async (event) => {
  console.log('📸 شروع پردازش تصویر:', JSON.stringify(event, null, 2));
  
  try {
    // استخراج اطلاعات از S3 event
    const bucket = event.Records[0].s3.bucket.name;
    const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));
    
    console.log(`📁 Bucket: ${bucket}, Key: ${key}`);
    
    // دانلود تصویر از S3
    const originalImage = await s3.getObject({
      Bucket: bucket,
      Key: key
    }).promise();
    
    // تنظیمات اندازه‌های مختلف
    const sizes = [
      { name: 'thumbnail', width: 150, height: 150 },
      { name: 'small', width: 400, height: 400 },
      { name: 'medium', width: 800, height: 600 },
      { name: 'large', width: 1200, height: 900 }
    ];
    
    const processedImages = [];
    
    // پردازش هر اندازه
    for (const size of sizes) {
      console.log(`🔄 پردازش اندازه ${size.name}...`);
      
      const resizedImage = await sharp(originalImage.Body)
        .resize(size.width, size.height, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({
          quality: 85,
          progressive: true
        })
        .toBuffer();
      
      // آپلود تصویر پردازش شده
      const newKey = key.replace(/\.[^/.]+$/, `_${size.name}.jpg`);
      
      await s3.putObject({
        Bucket: bucket,
        Key: newKey,
        Body: resizedImage,
        ContentType: 'image/jpeg',
        CacheControl: 'max-age=31536000', // 1 سال
        Metadata: {
          'original-key': key,
          'size': size.name,
          'width': size.width.toString(),
          'height': size.height.toString()
        }
      }).promise();
      
      processedImages.push({
        size: size.name,
        key: newKey,
        dimensions: `${size.width}x${size.height}`
      });
      
      console.log(`✅ ${size.name} آپلود شد: ${newKey}`);
    }
    
    // ارسال notification
    const message = {
      originalImage: key,
      processedImages: processedImages,
      bucket: bucket,
      timestamp: new Date().toISOString(),
      status: 'completed'
    };
    
    await sns.publish({
      TopicArn: process.env.SNS_TOPIC_ARN,
      Message: JSON.stringify(message),
      Subject: 'پردازش تصویر کامل شد'
    }).promise();
    
    console.log('📤 Notification ارسال شد');
    
    return {
      statusCode: 200,
      body: JSON.stringify({
        message: 'پردازش تصویر با موفقیت انجام شد',
        originalImage: key,
        processedImages: processedImages
      })
    };
    
  } catch (error) {
    console.error('❌ خطا در پردازش تصویر:', error);
    
    // ارسال error notification
    await sns.publish({
      TopicArn: process.env.SNS_ERROR_TOPIC_ARN,
      Message: JSON.stringify({
        error: error.message,
        stack: error.stack,
        event: event
      }),
      Subject: 'خطا در پردازش تصویر'
    }).promise();
    
    return {
      statusCode: 500,
      body: JSON.stringify({
        error: 'خطا در پردازش تصویر',
        message: error.message
      })
    };
  }
};
```

### 🤖 **Automation Scripts**

#### ۱. CI/CD Pipeline
```yaml
# درخواست: "یک GitHub Actions workflow کامل بساز"

name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '18'
  DOCKER_REGISTRY: 'ghcr.io'
  IMAGE_NAME: 'myapp'

jobs:
  # مرحله تست و بررسی کیفیت
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
      
    - name: 🟢 Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: 📦 Install dependencies
      run: |
        npm ci
        npm run install:all
        
    - name: 🔍 Lint code
      run: |
        npm run lint
        npm run lint:css
        
    - name: 🏗️ Build application
      run: npm run build
      
    - name: 🧪 Run unit tests
      run: npm run test:unit
      env:
        CI: true
        
    - name: 🔬 Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379
        
    - name: 🌐 Run E2E tests
      run: |
        npm run start:test &
        npm run test:e2e
        
    - name: 📊 Generate coverage report
      run: npm run test:coverage
      
    - name: 📤 Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        
    - name: 🔒 Security audit
      run: |
        npm audit --audit-level high
        npm run security:scan

  # مرحله build و deploy
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
      
    - name: 🐳 Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: 🔑 Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: 🏷️ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: 🏗️ Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: ☁️ Deploy to AWS ECS
      run: |
        # به‌روزرسانی ECS service
        aws ecs update-service \
          --cluster production-cluster \
          --service myapp-service \
          --force-new-deployment
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: us-east-1
        
    - name: 📢 Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      if: always()
```

## نکات عملی و بهترین شیوه‌ها

### 💡 **Tips برای استفاده بهینه**

#### ۱. تعامل مؤثر با Agent
```text
✅ درخواست‌های خوب:
"یک React component برای نمایش پروفایل کاربر بساز که شامل:
- نمایش اطلاعات شخصی
- امکان ویرایش
- validation برای فرم
- responsive design
- accessibility features"

❌ درخواست‌های ضعیف:
"یک component بساز"
"کد بنویس"
"این رو درست کن"
```

#### ۲. Context Management
```text
✅ Context مؤثر:
@src/components/UserProfile.tsx
@src/types/User.ts
@src/hooks/useUser.ts
@tests/UserProfile.test.tsx

❌ Context غیرمؤثر:
@src (خیلی گسترده)
@. (تمام پروژه)
```

#### ۳. Rules مؤثر
```markdown
# قوانین خوب:
## کدنویسی
- همیشه TypeScript استفاده کن
- از functional components استفاده کن
- error boundaries اضافه کن
- accessibility را رعایت کن

## تست
- هر component باید unit test داشته باشد
- coverage حداقل 80% باشد
- E2E test برای user flows اصلی

## امنیت
- input validation الزامی
- SQL injection prevention
- XSS protection
```

---

## خلاصه

این بخش مثال‌های عملی جامعی از:
- **پروژه‌های وب (Frontend/Backend)**
- **اپلیکیشن‌های موبایل**
- **پروژه‌های علوم داده**
- **سیستم‌های DevOps**
- **ابزارهای automation**

ارائه می‌دهد که نشان می‌دهد چگونه Cursor می‌تواند در انواع مختلف پروژه‌ها به شما کمک کند.

---
*این مثال‌ها نمونه‌هایی از قدرت Cursor در تولید کد کیفیت بالا و کامل هستند.*