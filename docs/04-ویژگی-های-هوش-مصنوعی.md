# ویژگی‌های هوش مصنوعی پیشرفته

## مدل‌های هوش مصنوعی

### 🧠 **مدل‌های پشتیبانی شده**

#### ۱. OpenAI Models
- **GPT-4o**: مدل قدرتمند و همه‌منظوره
  - پنجره زمینه: 128,000 توکن
  - قابلیت‌ها: کدنویسی، تحلیل، تولید متن
  - مناسب برای: پروژه‌های پیچیده

- **GPT-4o Mini**: نسخه سریع و کارآمد
  - پنجره زمینه: 128,000 توکن  
  - سرعت بالا با کیفیت مناسب
  - مناسب برای: تکمیل کد روزانه

#### ۲. Anthropic Models
- **Claude 3.5 Sonnet**: مدل پیشرفته برای تحلیل
  - پنجره زمینه: 200,000 توکن
  - تخصص در: تحلیل کد، refactoring
  - مناسب برای: بررسی و بهینه‌سازی کد

#### ۳. Cursor Native Models
- **Cursor Small**: مدل اختصاصی Cursor
  - بهینه شده برای تکمیل کد
  - سرعت بسیار بالا
  - مصرف کم منابع

#### ۴. حالت Auto
- انتخاب خودکار بهترین مدل
- بر اساس نوع درخواست
- بهینه‌سازی هزینه و کیفیت

### ⚙️ **تنظیمات مدل‌ها**

#### پارامترهای قابل تنظیم:

##### Temperature (خلاقیت)
```json
{
  "temperature": {
    "low": 0.1,      // محافظه‌کارانه، دقیق
    "medium": 0.5,   // متعادل (پیش‌فرض)
    "high": 0.9      // خلاق، متنوع
  }
}
```

##### Max Tokens (حداکثر طول پاسخ)
```json
{
  "maxTokens": {
    "short": 1000,   // پاسخ‌های کوتاه
    "medium": 4000,  // پاسخ‌های متوسط
    "long": 8000     // پاسخ‌های تفصیلی
  }
}
```

## ویژگی‌های پیشرفته AI

### 🎨 **Composer - ویرایشگر چندفایل هوشمند**

Composer ابزار قدرتمند Cursor برای ویرایش و ایجاد پروژه‌های پیچیده است.

#### قابلیت‌های Composer:

##### ۱. برنامه‌ریزی پروژه
```text
درخواست: "یک اپلیکیشن فروشگاه آنلاین با React و Node.js بساز"

Composer:
1. ساختار فولدرها را طراحی می‌کند
2. فایل‌های اصلی را ایجاد می‌کند  
3. وابستگی‌ها را مشخص می‌کند
4. کد اولیه را تولید می‌کند
```

##### ۲. ویرایش همزمان چندین فایل
- تغییرات هماهنگ در فایل‌های مرتبط
- حفظ consistency بین فایل‌ها
- مدیریت import/export ها
- به‌روزرسانی تست‌ها

##### ۳. مدیریت وابستگی‌ها
```json
// package.json خودکار
{
  "dependencies": {
    "react": "^18.0.0",
    "express": "^4.18.0",
    "mongoose": "^7.0.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "@types/react": "^18.0.0"
  }
}
```

#### نحوه استفاده از Composer:
1. **فعال‌سازی**: `Ctrl+Shift+I`
2. **توصیف پروژه**: شرح کاملی از نیازهای خود بدهید
3. **انتخاب فایل‌ها**: فایل‌های مرتبط را مشخص کنید
4. **بررسی تغییرات**: پیش‌نمایش تمام تغییرات
5. **اعمال**: تأیید و اجرای تغییرات

### 🔍 **Context-Aware Features - ویژگی‌های زمینه‌آگاه**

#### ۱. Symbol Search
```text
@symbol: useState
// پیدا کردن تمام موارد استفاده از useState در پروژه
```

#### ۲. File References  
```text
@file: UserController.js
// اشاره به فایل خاص برای تحلیل یا ویرایش
```

#### ۳. Folder Context
```text
@folder: src/components
// در نظر گیری کل پوشه کامپوننت‌ها
```

#### ۴. Codebase Search
```text
@codebase: authentication logic
// جستجوی معنایی در کل پروژه
```

### 🧪 **Advanced Code Generation**

#### ۱. Test Generation
```javascript
// کد اصلی
function calculateDiscount(price, percentage) {
    return price * (percentage / 100);
}

// درخواست: "تست برای این تابع بنویس"
// Agent تولید می‌کند:
describe('calculateDiscount', () => {
    test('should calculate discount correctly', () => {
        expect(calculateDiscount(100, 10)).toBe(10);
        expect(calculateDiscount(200, 25)).toBe(50);
    });
    
    test('should handle edge cases', () => {
        expect(calculateDiscount(0, 10)).toBe(0);
        expect(calculateDiscount(100, 0)).toBe(0);
    });
});
```

#### ۲. Documentation Generation
```javascript
/**
 * محاسبه تخفیف بر اساس قیمت و درصد
 * @param {number} price - قیمت اصلی محصول
 * @param {number} percentage - درصد تخفیف (0-100)
 * @returns {number} مقدار تخفیف محاسبه شده
 * @example
 * // محاسبه 10% تخفیف برای محصول 100 تومانی
 * const discount = calculateDiscount(100, 10); // 10
 */
function calculateDiscount(price, percentage) {
    return price * (percentage / 100);
}
```

#### ۳. Refactoring هوشمند
```javascript
// کد قبل از refactoring
function processUser(user) {
    if (user.age >= 18) {
        if (user.hasLicense) {
            if (user.hasInsurance) {
                return "approved";
            }
        }
    }
    return "rejected";
}

// پس از refactoring توسط Agent
function processUser(user) {
    const isAdult = user.age >= 18;
    const hasRequiredDocuments = user.hasLicense && user.hasInsurance;
    
    return isAdult && hasRequiredDocuments ? "approved" : "rejected";
}
```

## ادغام‌های خارجی

### 🔗 **Git Integration**

#### پیام‌های کامیت هوشمند:
```bash
# به جای نوشتن دستی:
git commit -m "fix user authentication bug"

# Cursor تولید می‌کند:
git commit -m "fix: resolve authentication timeout issue in UserService

- Add proper error handling for expired tokens
- Implement retry logic for failed requests  
- Update user session management
- Add unit tests for auth edge cases"
```

#### حل تعارضات:
```text
<<<<<<< HEAD
const apiUrl = 'https://api.old.com';
=======
const apiUrl = 'https://api.new.com';
>>>>>>> feature-branch

// Agent پیشنهاد می‌دهد:
const apiUrl = process.env.NODE_ENV === 'production' 
  ? 'https://api.new.com' 
  : 'https://api.old.com';
```

### 📱 **Slack Integration**

#### ویژگی‌های ادغام با Slack:
- **اعلان‌های build**: وضعیت build را در کانال اطلاع‌رسانی کنید
- **Code Review**: درخواست بررسی کد از طریق Slack
- **Agent در Slack**: پرسش مستقیم از Agent در کانال‌ها

#### تنظیم ادغام:
1. نصب اپ Cursor در Slack workspace
2. اتصال حساب Cursor به Slack
3. تنظیم کانال‌های مورد نظر
4. پیکربندی نوع اعلان‌ها

### 📋 **Linear Integration**

#### مدیریت وظایف:
- **ایجاد خودکار Issue**: تبدیل TODO ها به Linear issues
- **ردیابی پیشرفت**: به‌روزرسانی وضعیت کارها
- **تخمین زمان**: برآورد زمان لازم برای هر کار

#### نمونه workflow:
```text
1. Agent کد را تحلیل می‌کند
2. TODO های موجود را شناسایی می‌کند
3. در Linear issue ایجاد می‌کند
4. زمان تخمینی اختصاص می‌دهد
5. به developer اختصاص می‌دهد
```

### 🐙 **GitHub Integration**

#### ویژگی‌های GitHub:
- **Pull Request Review**: بررسی خودکار PR ها
- **Issue Management**: مدیریت و پاسخ به issue ها
- **Code Quality**: بررسی کیفیت کد در PR ها
- **Security Scan**: شناسایی مشکلات امنیتی

## ویژگی‌های علوم داده

### 📊 **پشتیبانی از Jupyter Notebooks**

#### قابلیت‌های Notebook:
- **اجرای سلول‌ها**: اجرای مستقیم کد Python
- **تصویری‌سازی**: نمایش نمودارها و گراف‌ها
- **تحلیل داده**: کمک AI در تحلیل dataset ها
- **تولید کد**: ایجاد کد تحلیلی بر اساس داده‌ها

#### مثال کاربرد:
```python
# درخواست: "نمودار فروش ماهانه را نمایش بده"
import matplotlib.pyplot as plt
import pandas as pd

# خواندن داده‌ها
sales_data = pd.read_csv('monthly_sales.csv')

# ایجاد نمودار
plt.figure(figsize=(12, 6))
plt.plot(sales_data['month'], sales_data['sales'])
plt.title('نمودار فروش ماهانه')
plt.xlabel('ماه')
plt.ylabel('فروش (تومان)')
plt.show()
```

### 🗄️ **ادغام با پایگاه‌های داده**

#### پشتیبانی از پایگاه‌های داده:
- **PostgreSQL**: کوئری‌های پیچیده SQL
- **MongoDB**: کار با NoSQL و aggregation
- **MySQL**: تحلیل داده‌های رابطه‌ای
- **SQLite**: پایگاه‌های داده محلی

#### نمونه کوئری هوشمند:
```sql
-- درخواست: "کاربرانی که بیشترین خرید را داشته‌اند"
SELECT 
    u.name,
    u.email,
    COUNT(o.id) as total_orders,
    SUM(o.amount) as total_spent
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR)
GROUP BY u.id
ORDER BY total_spent DESC
LIMIT 10;
```

## قابلیت‌های پیشرفته Context

### 🎯 **Context Selection Strategies**

#### ۱. Smart Context
```text
Agent خودکار فایل‌های مرتبط را انتخاب می‌کند:
- فایل‌های import شده
- فایل‌های مرتبط در ساختار
- تست‌های مربوطه
- فایل‌های پیکربندی
```

#### ۲. Manual Context
```text
@src/utils/helpers.js
@tests/unit/helpers.test.js
@docs/api.md

"این helper function را بهینه کن"
```

#### ۳. Semantic Context
```text
@codebase: user authentication
// جستجوی معنایی برای یافتن کدهای مرتبط با احراز هویت
```

### 🔄 **Memory Management**

#### انواع حافظه:

##### ۱. Session Memory
- حافظه جلسه فعلی
- تصمیمات گرفته شده در مکالمه
- زمینه پروژه فعلی

##### ۲. Project Memory  
- حافظه دائمی پروژه
- قراردادهای کدنویسی
- تصمیمات معماری

##### ۳. Global Memory
- حافظه کاربر در تمام پروژه‌ها
- ترجیحات شخصی
- سبک کدنویسی

#### مدیریت حافظه:
```json
{
  "memorySettings": {
    "autoSave": true,
    "retentionDays": 30,
    "maxMemories": 100,
    "categories": [
      "architecture",
      "coding-style", 
      "preferences",
      "decisions"
    ]
  }
}
```

## Rules - سیستم قوانین پیشرفته

### 📋 **انواع قوانین**

#### ۱. Project Rules
```markdown
# .cursor/rules

## معماری
- از Clean Architecture استفاده کن
- هر layer مسئولیت مشخصی داشته باشد
- dependency injection را رعایت کن

## کدنویسی  
- همیشه TypeScript استفاده کن
- از functional programming پیروی کن
- error handling الزامی است

## تست
- coverage حداقل 80% باشد
- unit test برای هر function
- integration test برای API ها

## امنیت
- input validation الزامی
- SQL injection prevention
- XSS protection
```

#### ۲. User Rules
```json
{
  "userRules": [
    "همیشه کامنت‌های فارسی بنویس",
    "از async/await به جای Promise استفاده کن", 
    "کد را readable و maintainable نگه دار",
    "performance را در نظر بگیر"
  ]
}
```

#### ۳. Dynamic Rules (Memories)
```text
خودکار از مکالمات ایجاد می‌شود:
- "در این پروژه از Material-UI استفاده می‌کنیم"
- "API responses باید camelCase باشند"
- "error messages باید user-friendly باشند"
```

### 🎛️ **Rule Management**

#### اولویت‌بندی قوانین:
1. **Project Rules** (بالاترین اولویت)
2. **Memories** 
3. **User Rules** (کمترین اولویت)

#### مدیریت تعارض:
```text
اگر قوانین متضاد باشند:
- قوانین پروژه اولویت دارند
- Agent تعارض را گزارش می‌دهد
- پیشنهاد حل تعارض ارائه می‌دهد
```

## Model Context Protocol (MCP)

### 🔌 **اتصال به ابزارهای خارجی**

MCP پروتکلی برای اتصال Cursor به ابزارها و سرویس‌های خارجی است.

#### ابزارهای قابل اتصال:
- **پایگاه‌های داده**: PostgreSQL، MongoDB، Redis
- **API های خارجی**: REST، GraphQL، gRPC
- **ابزارهای DevOps**: Docker، Kubernetes، AWS
- **سیستم‌های مانیتورینگ**: Prometheus، Grafana

#### مثال اتصال به پایگاه داده:
```json
{
  "mcp": {
    "servers": {
      "postgres": {
        "command": "mcp-server-postgres",
        "args": ["--connection-string", "postgresql://..."],
        "env": {
          "DB_HOST": "localhost",
          "DB_PORT": "5432"
        }
      }
    }
  }
}
```

### 🛠️ **Custom Tools**

#### ایجاد ابزار سفارشی:
```python
# custom_tool.py
def analyze_performance(code):
    """تحلیل عملکرد کد"""
    # منطق تحلیل
    return performance_report

# ثبت در MCP
register_tool("performance_analyzer", analyze_performance)
```

## بهینه‌سازی عملکرد AI

### ⚡ **استراتژی‌های بهینه‌سازی**

#### ۱. Context Optimization
```json
{
  "contextOptimization": {
    "maxFiles": 10,
    "maxTokensPerFile": 2000,
    "prioritizeRecentFiles": true,
    "excludePatterns": [
      "*.log",
      "node_modules/**",
      "dist/**"
    ]
  }
}
```

#### ۲. Model Selection Strategy
```text
تکمیل کد ساده → Cursor Small (سریع)
تحلیل پیچیده → Claude 3.5 (دقیق)  
تولید کد جدید → GPT-4o (خلاق)
بررسی کد → Claude 3.5 (تحلیلی)
```

#### ۳. Caching Strategy
- **Local Cache**: ذخیره پیشنهادات محلی
- **Session Cache**: حفظ زمینه در طول جلسه
- **Project Cache**: کش اطلاعات پروژه

### 📈 **مانیتورینگ عملکرد**

#### متریک‌های مهم:
- **Response Time**: زمان پاسخ‌دهی
- **Accuracy**: دقت پیشنهادات
- **Usage Patterns**: الگوهای استفاده
- **Error Rates**: نرخ خطاها

#### داشبورد عملکرد:
```json
{
  "performance": {
    "avgResponseTime": "1.2s",
    "accuracyRate": "94%",
    "dailyRequests": 150,
    "errorRate": "2%"
  }
}
```

## امنیت و حریم خصوصی

### 🔒 **تنظیمات امنیتی**

#### ۱. حالت خصوصی (Private Mode)
```json
{
  "privacy": {
    "sendCodeToServer": false,
    "localProcessingOnly": true,
    "encryptData": true,
    "anonymizeCode": true
  }
}
```

#### ۲. کنترل داده‌ها
- **فیلتر فایل‌ها**: مشخص کردن فایل‌های قابل ارسال
- **حذف اطلاعات حساس**: فیلتر خودکار API keys و passwords
- **کنترل دسترسی**: محدودیت دسترسی Agent به فایل‌ها

#### ۳. رمزنگاری
- **انتقال داده**: رمزنگاری TLS 1.3
- **ذخیره محلی**: رمزنگاری AES-256
- **کلیدهای API**: ذخیره امن در keychain سیستم

### 🛡️ **بهترین شیوه‌های امنیتی**

#### برای پروژه‌های تجاری:
```markdown
## چک‌لیست امنیت
- [ ] فعال‌سازی Private Mode
- [ ] تنظیم فیلتر فایل‌ها
- [ ] بررسی Rules برای اطلاعات حساس
- [ ] تست عدم ارسال credentials
- [ ] مرور منظم Memories
```

---

## نکات عملی

### 💡 **بهترین شیوه‌های استفاده**

#### ۱. تنظیم محیط بهینه
- قوانین واضح و مفصل تعریف کنید
- فایل‌های غیرضروری را از context حذف کنید
- Memory ها را منظماً بررسی و به‌روزرسانی کنید

#### ۲. تعامل مؤثر با Agent
- درخواست‌های واضح و مفصل ارسال کنید
- زمینه کافی برای تصمیم‌گیری فراهم کنید
- نتایج را بررسی و feedback بدهید

#### ۳. مدیریت پروژه‌های بزرگ
- از Composer برای تغییرات گسترده استفاده کنید
- پروژه را به ماژول‌های کوچک‌تر تقسیم کنید
- Context را به بخش‌های مرتبط محدود کنید

---

## مرحله بعدی

در بخش بعدی، با **ادغام‌های خارجی** و **ابزارهای تکمیلی** Cursor آشنا خواهید شد.

---
*این مستند راهنمای جامعی از ویژگی‌های هوش مصنوعی Cursor ارائه می‌دهد. برای آخرین به‌روزرسانی‌ها، [مستندات رسمی](https://docs.cursor.com) را دنبال کنید.*